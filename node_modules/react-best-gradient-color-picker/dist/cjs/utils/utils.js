"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectToString = exports.getDegrees = exports.compareGradients = exports.isUpperCase = exports.getNewHsl = exports.getGradientType = exports.computePickerPosition = exports.computeSquareXY = exports.getHandleValue = exports.safeBounds = void 0;
const formatters_js_1 = require("./formatters.js");
const constants_js_1 = require("../constants.js");
const tinycolor2_1 = __importDefault(require("tinycolor2"));
const { barSize, crossSize } = constants_js_1.config;
const safeBounds = (e) => {
    const client = e.target.parentNode.getBoundingClientRect();
    const className = e.target.className;
    const adjuster = className === 'c-resize ps-rl' ? 15 : 0;
    return {
        offsetLeft: client?.x + adjuster,
        offsetTop: client?.y,
        clientWidth: client?.width,
        clientHeight: client?.height,
    };
};
exports.safeBounds = safeBounds;
function getHandleValue(e) {
    const { offsetLeft, clientWidth } = (0, exports.safeBounds)(e);
    const pos = e.clientX - offsetLeft - barSize / 2;
    const adjuster = clientWidth - 18;
    const bounded = (0, formatters_js_1.formatInputValues)(pos, 0, adjuster);
    return Math.round(bounded / (adjuster / 100));
}
exports.getHandleValue = getHandleValue;
function computeSquareXY(hsl, squareSize, squareHeight) {
    if (hsl[1] && hsl[2]) {
        const s = hsl[1] * 100;
        const l = hsl[2] * 100;
        const t = (s * (l < 50 ? l : 100 - l)) / 100;
        const s1 = Math.round((200 * t) / (l + t)) | 0;
        const b1 = Math.round(t + l);
        const x = (squareSize / 100) * s1 - crossSize / 2;
        const y = squareHeight - (squareHeight / 100) * b1 - crossSize / 2;
        return [x, y];
    }
    else {
        return [0, 0];
    }
}
exports.computeSquareXY = computeSquareXY;
const getClientXY = (e) => {
    if (e.clientX) {
        return { clientX: e.clientX, clientY: e.clientY };
    }
    else {
        const touch = e.touches[0] || {};
        return { clientX: touch.clientX, clientY: touch.clientY };
    }
};
function computePickerPosition(e) {
    const { offsetLeft, offsetTop, clientWidth, clientHeight } = (0, exports.safeBounds)(e);
    const { clientX, clientY } = getClientXY(e);
    const getX = () => {
        const xPos = clientX - offsetLeft - crossSize / 2;
        return (0, formatters_js_1.formatInputValues)(xPos, -9, clientWidth - 10);
    };
    const getY = () => {
        const yPos = clientY - offsetTop - crossSize / 2;
        return (0, formatters_js_1.formatInputValues)(yPos, -9, clientHeight - 10);
    };
    return [getX(), getY()];
}
exports.computePickerPosition = computePickerPosition;
const getGradientType = (value) => {
    return value?.split('(')[0];
};
exports.getGradientType = getGradientType;
const getNewHsl = (newHue, s, l, o, setInternalHue) => {
    setInternalHue(newHue);
    const tiny = (0, tinycolor2_1.default)({ h: newHue, s: s, l: l });
    const { r, g, b } = tiny.toRgb();
    return `rgba(${r}, ${g}, ${b}, ${o})`;
};
exports.getNewHsl = getNewHsl;
const isUpperCase = (str) => {
    return str?.[0] === str?.[0]?.toUpperCase();
};
exports.isUpperCase = isUpperCase;
const compareGradients = (g1, g2) => {
    const ng1 = g1?.toLowerCase()?.replaceAll(' ', '');
    const ng2 = g2?.toLowerCase()?.replaceAll(' ', '');
    if (ng1 === ng2) {
        return true;
    }
    else {
        return false;
    }
};
exports.compareGradients = compareGradients;
const convertShortHandDeg = (dir) => {
    if (dir === 'to top') {
        return 0;
    }
    else if (dir === 'to bottom') {
        return 180;
    }
    else if (dir === 'to left') {
        return 270;
    }
    else if (dir === 'to right') {
        return 90;
    }
    else if (dir === 'to top right') {
        return 45;
    }
    else if (dir === 'to bottom right') {
        return 135;
    }
    else if (dir === 'to bottom left') {
        return 225;
    }
    else if (dir === 'to top left') {
        return 315;
    }
    else {
        const safeDir = dir || 0;
        return parseInt(safeDir);
    }
};
const getDegrees = (value) => {
    const s1 = value?.split(',')[0];
    const s2 = s1?.split('(')[1]?.replace('deg', '');
    return convertShortHandDeg(s2);
};
exports.getDegrees = getDegrees;
const objectToString = (value) => {
    if (typeof value === 'string') {
        return value;
    }
    else {
        if (value?.type?.includes('gradient')) {
            const sorted = value?.colorStops?.sort((a, b) => a?.left - b?.left);
            const string = sorted
                ?.map((c) => `${c?.value} ${c?.left}%`)
                ?.join(', ');
            const type = value?.type;
            const degs = convertShortHandDeg(value?.orientation?.value);
            const gradientStr = type === 'linear-gradient' ? `${degs}deg` : 'circle';
            return `${type}(${gradientStr}, ${string})`;
        }
        else {
            const color = value?.colorStops[0]?.value || 'rgba(175, 51, 242, 1)';
            return color;
        }
    }
};
exports.objectToString = objectToString;
