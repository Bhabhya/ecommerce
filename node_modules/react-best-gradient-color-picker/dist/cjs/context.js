"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePicker = void 0;
const react_1 = __importStar(require("react"));
const utils_js_1 = require("./utils/utils.js");
const formatters_js_1 = require("./utils/formatters.js");
const constants_js_1 = require("./constants.js");
const tinycolor2_1 = __importDefault(require("tinycolor2"));
const { crossSize } = constants_js_1.config;
const PickerContext = (0, react_1.createContext)(null);
function PickerContextWrapper({ value, bounds, children, onChange, squareSize, hideOpacity, squareHeight, }) {
    const offsetLeft = bounds?.x;
    const isGradient = value?.includes('gradient');
    const gradientType = (0, utils_js_1.getGradientType)(value);
    const degrees = (0, utils_js_1.getDegrees)(value);
    const degreeStr = gradientType === 'linear-gradient' ? `${degrees}deg` : 'circle';
    const colors = (0, formatters_js_1.getColors)(value);
    const indexedColors = colors?.map((c, i) => ({
        ...c,
        index: i,
    }));
    const currentColorObj = indexedColors?.filter((c) => (0, utils_js_1.isUpperCase)(c.value))[0] ||
        indexedColors[0];
    const currentColor = currentColorObj?.value;
    const selectedColor = currentColorObj?.index;
    const currentLeft = currentColorObj?.left;
    const [tinyColor, setTinyColor] = (0, react_1.useState)((0, tinycolor2_1.default)(currentColor));
    const [inputType, setInputType] = (0, react_1.useState)('rgb');
    const { r, g, b, a: opacity } = tinyColor.toRgb();
    const { h: hue, s, l } = tinyColor.toHsl();
    const { s: hsvS, v: hsvV } = tinyColor.toHsv();
    const [internalHue, setInternalHue] = (0, react_1.useState)(Math.round(hue));
    const [x, y] = (0, utils_js_1.computeSquareXY)([hue, s, l], squareSize, squareHeight);
    const [previousColors, setPreviousColors] = (0, react_1.useState)([]);
    const [previousGraidents, setPreviousGradients] = (0, react_1.useState)([]);
    const [inFocus, setInFocus] = (0, react_1.useState)(null);
    const useragent = navigator.userAgent || '';
    const isMobile = useragent?.includes('Mobile');
    const internalOnChange = (newValue) => {
        if (newValue !== value) {
            if (isGradient) {
                if (!(0, utils_js_1.compareGradients)(previousGraidents[0] || '', value)) {
                    setPreviousGradients([value, ...previousGraidents.slice(0, 8)]);
                }
            }
            else {
                setPreviousColors([value, ...previousColors.slice(0, 8)]);
            }
            onChange(newValue);
        }
    };
    (0, react_1.useEffect)(() => {
        setTinyColor((0, tinycolor2_1.default)(currentColor));
    }, [currentColor]);
    const createGradientStr = (newColors) => {
        const sorted = newColors.sort((a, b) => a.left - b.left);
        const colorString = sorted?.map((cc) => `${cc?.value} ${cc.left}%`);
        internalOnChange(`${gradientType}(${degreeStr}, ${colorString.join(', ')})`);
    };
    const handleGradient = (newColor, left) => {
        const remaining = colors?.filter((c) => !(0, utils_js_1.isUpperCase)(c.value));
        const newColors = [
            { value: newColor.toUpperCase(), left: left || currentLeft },
            ...remaining,
        ];
        createGradientStr(newColors);
    };
    const handleChange = (newColor) => {
        if (isGradient) {
            handleGradient(newColor);
        }
        else {
            internalOnChange(newColor);
        }
    };
    const handleOpacity = (e) => {
        const newO = (0, utils_js_1.getHandleValue)(e) / 100;
        const newColor = `rgba(${r}, ${g}, ${b}, ${newO})`;
        handleChange(newColor);
    };
    const handleHue = (e) => {
        const newHue = (0, utils_js_1.getHandleValue)(e) * 3.6;
        const newHsl = (0, utils_js_1.getNewHsl)(newHue, s, l, opacity, setInternalHue);
        handleChange(newHsl);
    };
    const handleColor = (e, ctx) => {
        const [x, y] = (0, utils_js_1.computePickerPosition)(e);
        if (x && y) {
            const x1 = Math.min(x + crossSize / 2, squareSize - 1);
            const y1 = Math.min(y + crossSize / 2, squareHeight - 1);
            const [r, g, b] = ctx.getImageData(x1, y1, 1, 1).data;
            const rgbaData = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            const newTc = (0, tinycolor2_1.default)(rgbaData);
            // @ts-expect-error some problem with certain tinycolor functions when importing module
            const newHsl = newTc.toHsl(newTc);
            const fixedH = (0, tinycolor2_1.default)({
                h: hue,
                s: newHsl?.s,
                l: newHsl?.l,
                a: newHsl?.a,
            });
            handleChange(
            // @ts-expect-error some problem with certain tinycolor functions when importing module
            `rgba(${fixedH?._r}, ${fixedH?._g}, ${fixedH?._b}, ${fixedH?._a})`);
        }
    };
    const setSelectedColor = (index) => {
        const newGradStr = colors?.map((cc, i) => ({
            ...cc,
            value: i === index ? (0, formatters_js_1.high)(cc) : (0, formatters_js_1.low)(cc),
        }));
        createGradientStr(newGradStr);
    };
    const addPoint = (e) => {
        const left = (0, utils_js_1.getHandleValue)(e);
        const newColors = [
            ...colors.map((c) => ({ ...c, value: (0, formatters_js_1.low)(c) })),
            { value: currentColor, left: left },
        ]?.sort((a, b) => a.left - b.left);
        createGradientStr(newColors);
    };
    const deletePoint = () => {
        if (colors?.length > 2) {
            const formatted = colors?.map((fc, i) => ({
                ...fc,
                value: i === selectedColor - 1 ? (0, formatters_js_1.high)(fc) : (0, formatters_js_1.low)(fc),
            }));
            const remaining = formatted?.filter((_, i) => i !== selectedColor);
            createGradientStr(remaining);
        }
    };
    const nextPoint = () => {
        if (selectedColor !== colors?.length - 1) {
            setSelectedColor(selectedColor + 1);
        }
    };
    const handleClickFocus = (e) => {
        const formattedPath = e?.path?.map((el) => el.id);
        if (formattedPath?.includes('gradient-bar')) {
            setInFocus('gpoint');
        }
        else if (formattedPath?.includes('rbgcp-input')) {
            setInFocus('input');
        }
        else if (formattedPath?.includes('rbgcp-wrapper')) {
            setInFocus('picker');
        }
        else {
            setInFocus(null);
        }
    };
    (0, react_1.useEffect)(() => {
        window.addEventListener('click', handleClickFocus);
        // window.addEventListener('keydown', handleKeyboard)
        return () => {
            window.removeEventListener('click', handleClickFocus);
            // window.removeEventListener('keydown', handleKeyboard)
        };
    }, [inFocus, value]);
    const pickerContext = {
        x,
        y,
        s,
        l,
        r,
        g,
        b,
        hue,
        hsvS,
        hsvV,
        value,
        colors,
        degrees,
        inFocus,
        opacity,
        isMobile,
        onChange,
        addPoint,
        inputType,
        nextPoint,
        tinyColor,
        handleHue,
        setInFocus,
        isGradient,
        offsetLeft,
        squareSize,
        hideOpacity,
        handleColor,
        currentLeft,
        deletePoint,
        internalHue,
        squareHeight,
        setInputType,
        gradientType,
        handleChange,
        currentColor,
        selectedColor,
        handleOpacity,
        setInternalHue,
        previousColors,
        handleGradient,
        setSelectedColor,
        internalOnChange,
        previousGraidents,
    };
    return (react_1.default.createElement(PickerContext.Provider, { value: pickerContext }, children));
}
exports.default = PickerContextWrapper;
function usePicker() {
    const pickerContext = (0, react_1.useContext)(PickerContext);
    if (!pickerContext) {
        throw new Error('usePicker has to be used within <PickerContext.Provider>');
    }
    return pickerContext;
}
exports.usePicker = usePicker;
